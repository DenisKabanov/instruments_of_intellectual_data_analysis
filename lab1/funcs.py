import numpy as np
from numba import njit, float64, int32

@njit #====================== использовать ли numba компилятор для функции ============================
def match_timestamps_naive(timestamps1: np.ndarray, timestamps2: np.ndarray) -> np.ndarray: 
    """
    * Делаем для каждого элемента первого массива: - O(n)
            * из всех элементов второго массива вычитается элемент первого массива (считаем delta) за O(2n) ~ O(n)
            * в получившихся delta ищем наименьший элемент за O(2n) ~ O(n)\n
    Итоговая сложность: O(размер_первого_массива * (размер_второго_массива + размер_второго_массива)) = O(n*(2n+2n)) = O(4n^2) ~ O(n^2)
    Parameters:
        * timestamps1: массив с временами с камеры 1
        * timestamps2: массив с временами с камеры 2\n
    Returns:
        * np.ndarray: массив соответствий кадров с камеры 1 к кадрам камеры 2
    """

    # так как в задании первая камера пишет в ~30 fps -> размер первого массива n; вторая камера пишет в ~60 fps -> размер второго массива не сильно больше 2n; сокращаем на константы и получаем n
    frames_count = timestamps1.shape[0] # число кадров на камере 1
    correspondence = np.zeros(frames_count, dtype=np.int32) # создаём массив под номера кадров с типом int32 для уменьшения потребляемой памяти

    #===================== вариант с циклом в np.arange ================================================
    # for frame in np.arange(frames_count): # идём по номерам кадров
    #--------------------- вариант с циклом в enumerate ------------------------------------------------
    for frame, frame_time in enumerate(timestamps1): # идём по кадрам
    #===================================================================================================
        #===================== вариант с сохранением delta =============================================
        # deltas = np.absolute(timestamps2 - timestamps1[frame]) # считаем разницу между временами
        # correspondence[frame] = deltas.argmin() # берём номер кадра с наименьшей разницей
        #--------------------- вариант без сохранения delta --------------------------------------------
        correspondence[frame] = np.absolute(timestamps2 - frame_time).argmin() # цикл с enumerate
        # correspondence[frame] = np.absolute(timestamps2 - timestamps1[frame]).argmin() # цикл с np.arange
        #===============================================================================================

    return correspondence



@njit #====================== использовать ли numba компилятор для функции ============================
def match_timestamps_iterated(timestamps1: np.ndarray, timestamps2: np.ndarray, cam2_frame: np.int32=0) -> np.ndarray: 
    """
    * Ищем начальный кадр для второй камеры - O(2n), однако реальная сложность меньше, так как cam2_frame уже найден эвристически с учётом числа кадров на первой и второй камере
    * Делаем для каждого элемента (времени) с первой камеры: - O(n)
            * Вычитаем из соответствующего времени кадра второй камеры значение времени кадра с первой камеры - O(2n) в худшем случае, O(2) ~ O(1) в среднем, так как кадры распределены равномерно и во втором массиве не на порядок больше элементов
                    * если дельта уменьшилась - переходим к следующему кадру на второй камере и так далее, пока дельта уменьшается\n
                    * если дельта не уменьшилась - возвращаем предыдущий кадр, как самый близкий по времени\n
    Итоговая сложность: O(размер_второго_массива + размер_первого_массива * размер_второго_массива) ~ [в среднем] ~ O(размер_второго_массива + размер_первого_массива * 1) ~ O(n) \n
    Parameters:
        * timestamps1: массив с временами с камеры 1
        * timestamps2: массив с временами с камеры 2
        * cam2_frame: с какого элемента рассматривать кадры с камеры 2 (важен при параллельном запуске)\n
    Returns:
        * np.ndarray: массив соответствий кадров с камеры 1 к кадрам камеры 2
    """

    # так как в задании первая камера пишет в ~30 fps -> размер первого массива n; вторая камера пишет в ~60 fps -> размер второго массива не сильно больше 2n; сокращаем на константы и получаем n
    frames_count = timestamps1.shape[0] # число кадров на камере 1
    max_frame = timestamps2.shape[0] - 1 # максимальный номер кадра, что может соответствовать кадру с первой камеры (-1 из-за индексации с нуля)
    correspondence = np.zeros(frames_count, dtype=np.int32) # создаём массив под номера кадров с типом int32 для уменьшения потребляемой памяти

    if 0 > cam2_frame or cam2_frame > max_frame: # защита от дурака с cam2_frame
        cam2_frame = 0 # зануление начального кадра второй камеры

    # подбираем кадр на второй камере, с которого будем начинать (эвристически уже передали ожидаемый cam2_frame, нужно его лишь правильно сместить, если он "обогнал" кадры с камеры 1)
    delta = np.abs(timestamps2[cam2_frame] - timestamps1[0]) # текущая разность времени
    while np.abs(timestamps2[max(0, cam2_frame-1)] - timestamps1[0]) < delta: # если дельта уменьшается при предыдущем кадре, то переходим на него (условие — строго меньше, так как времена всех кадров уникальны)
        cam2_frame -= 1 # переходим на предыдущий кадр (без max, так как при нуле мы бы сюда не зашли в цикл)
        delta = np.abs(timestamps2[cam2_frame] - timestamps1[0]) # обновляем текущее значение delta (без max, так как при нуле мы бы не зашли в цикл)
    # после этого цикла мы либо находимся на оптимальном соответствии первого кадра первой камеры с кадром со второй камеры, либо оптимум — далее по времени (но не раньше!)

    #===================== вариант с циклом в np.arange ================================================
    # for frame in np.arange(frames_count): # идём по номерам кадров с первой камеры
    #     delta = np.abs(timestamps2[cam2_frame] - timestamps1[frame]) # текущая разность времени
    #     while np.abs(timestamps2[min(cam2_frame+1, max_frame)] - timestamps1[frame]) < delta: # если при переходе на следующий кадр дельта (разница времени) уменьшилась, то обновляем delta и соответствующий кадр на второй камере 
    #         cam2_frame += 1 # переходим на следующий кадр
    #         delta = np.abs(timestamps2[cam2_frame] - timestamps1[frame])  # обновляем delta
    #     correspondence[frame] = cam2_frame # если дельта перестала уменьшаеться — записываем найденный кадр
    #--------------------- вариант с циклом в enumerate ------------------------------------------------
    for frame, frame_time in enumerate(timestamps1): # идём по кадрам
        delta = np.abs(timestamps2[cam2_frame] - frame_time) # текущая разность времени
        while np.abs(timestamps2[min(cam2_frame+1, max_frame)] - frame_time) < delta: # если при переходе на следующий кадр дельта (разница времени) уменьшилась, то обновляем delta и соответствующий кадр на второй камере 
            cam2_frame += 1 # переходим на следующий кадр
            delta = np.abs(timestamps2[cam2_frame] - frame_time)  # обновляем delta
        correspondence[frame] = cam2_frame # если дельта перестала уменьшаеться — записываем найденный кадр
    #===============================================================================================

    return correspondence